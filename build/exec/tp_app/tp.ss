#!/usr/bin/chezscheme --program

;; @generated by Idris 0.7.0-5d04f89c7, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx tarm64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.so")

(let ()
(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

; flonum constants

(define (blodwen-calcFlonumUnitRoundoff)
  (let loop [(uro 1.0)]
    (if (fl= 1.0 (fl+ 1.0 uro))
      uro
      (loop (fl/ uro 2.0)))))

(define (blodwen-calcFlonumEpsilon)
  (fl* (blodwen-calcFlonumUnitRoundoff) 2.0))

(define (blodwen-flonumNaN)
  +nan.0)

(define (blodwen-flonumInf)
  +inf.0)

; Bits

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint8 buf loc val)
  (bytevector-s8-set! buf loc val))

(define (blodwen-buffer-getint8 buf loc)
  (bytevector-s8-ref buf loc))

(define (blodwen-buffer-setint16 buf loc val)
  (bytevector-s16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint16 buf loc)
  (bytevector-s16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint64 buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint64 buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work)])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))


(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45Types-fastUnpack (lambda (farg-0) (string-unpack farg-0)))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Integer (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Integer (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Integer (vector 0 ) arg-0)))
(define csegen-1 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_Integer u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_Integer u--d u--x)))))
(define PreludeC-45Types-getAt (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (box e-3))))(else (let ((e-1 (- arg-1 1))) (if (null? arg-2) '() (let ((e-7 (cdr arg-2))) (PreludeC-45Types-getAt e-1 e-7))))))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char<=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Types-isDigit (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\0))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\9)) (else 0)))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define PreludeC-45Show-protectEsc (lambda (arg-0 arg-1 arg-2) (string-append arg-1 (string-append (let ((sc0 (PreludeC-45Show-firstCharIs arg-0 arg-2))) (cond ((equal? sc0 1) "\\&") (else ""))) arg-2))))
(define PreludeC-45EqOrd-u--C-62_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-u--showPrec_Show_Int (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Int (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Int (vector 0 ) arg-0)))
(define PreludeC-45Show-n--2439-11931-u--asciiTab (lambda (arg-0) (cons "NUL" (cons "SOH" (cons "STX" (cons "ETX" (cons "EOT" (cons "ENQ" (cons "ACK" (cons "BEL" (cons "BS" (cons "HT" (cons "LF" (cons "VT" (cons "FF" (cons "CR" (cons "SO" (cons "SI" (cons "DLE" (cons "DC1" (cons "DC2" (cons "DC3" (cons "DC4" (cons "NAK" (cons "SYN" (cons "ETB" (cons "CAN" (cons "EM" (cons "SUB" (cons "ESC" (cons "FS" (cons "GS" (cons "RS" (cons "US" '()))))))))))))))))))))))))))))))))))
(define PreludeC-45Show-showLitChar (lambda (arg-0) (cond ((equal? arg-0 (integer->char 7)) (lambda (arg-1) (string-append "\\a" arg-1))) ((equal? arg-0 (integer->char 8)) (lambda (arg-1) (string-append "\\b" arg-1))) ((equal? arg-0 (integer->char 12)) (lambda (arg-1) (string-append "\\f" arg-1))) ((equal? arg-0 (integer->char 10)) (lambda (arg-1) (string-append "\\n" arg-1))) ((equal? arg-0 (integer->char 13)) (lambda (arg-1) (string-append "\\r" arg-1))) ((equal? arg-0 (integer->char 9)) (lambda (arg-1) (string-append "\\t" arg-1))) ((equal? arg-0 (integer->char 11)) (lambda (arg-1) (string-append "\\v" arg-1))) ((equal? arg-0 (integer->char 14)) (lambda (eta-0) (PreludeC-45Show-protectEsc (lambda (arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-1 #\H)) "\\SO" eta-0))) ((equal? arg-0 (integer->char 127)) (lambda (arg-1) (string-append "\\DEL" arg-1))) ((equal? arg-0 #\\) (lambda (arg-1) (string-append "\\\\" arg-1)))(else (lambda (clam-0) (let ((sc0 (PreludeC-45Types-getAt (PreludeC-45Types-prim__integerToNat (char->integer arg-0)) (PreludeC-45Show-n--2439-11931-u--asciiTab arg-0)))) (if (null? sc0) (let ((sc1 (PreludeC-45EqOrd-u--C-62_Ord_Char arg-0 (integer->char 127)))) (cond ((equal? sc1 1) (string-cons #\\ (PreludeC-45Show-protectEsc (lambda (eta-0) (PreludeC-45Types-isDigit eta-0)) (PreludeC-45Show-u--show_Show_Int (cast-char-boundedInt arg-0 63)) clam-0))) (else (string-cons arg-0 clam-0)))) (let ((e-1 (unbox sc0))) (string-cons #\\ (string-append e-1 clam-0))))))))))
(define PreludeC-45Show-showLitString (lambda (arg-0) (lambda (clam-0) (if (null? arg-0) clam-0 (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cond ((equal? e-2 #\") (string-append "\\\"" ((PreludeC-45Show-showLitString e-3) clam-0)))(else ((PreludeC-45Show-showLitChar e-2) ((PreludeC-45Show-showLitString e-3) clam-0))))))))))
(define PreludeC-45Show-u--show_Show_String (lambda (arg-0) (string-cons #\" ((PreludeC-45Show-showLitString (PreludeC-45Types-fastUnpack arg-0)) "\""))))
(define PreludeC-45Show-u--showPrec_Show_String (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_String arg-1)))
(define csegen-38 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_String u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_String u--d u--x)))))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define PreludeC-45TypesC-45List-reverseOnto (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-reverseOnto (cons e-2 arg-1) e-3))))))
(define PreludeC-45TypesC-45List-reverse (lambda (ext-0) (PreludeC-45TypesC-45List-reverseOnto '() ext-0)))
(define PreludeC-45TypesC-45List-tailRecAppend (lambda (arg-1 arg-2) (PreludeC-45TypesC-45List-reverseOnto arg-2 (PreludeC-45TypesC-45List-reverse arg-1))))
(define Converter-n--4439-5807-u--buildGroup (lambda (arg-1 arg-2 arg-3 arg-4 arg-5 arg-6) (if (null? arg-5) (cons arg-6 '()) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((sc1 ((arg-3 arg-4) e-2))) (cond ((equal? sc1 1) (Converter-n--4439-5807-u--buildGroup arg-1 arg-2 arg-3 e-2 e-3 (PreludeC-45TypesC-45List-tailRecAppend arg-6 (cons e-2 '())))) (else (cons arg-6 (Converter-n--4439-5807-u--buildGroup arg-1 arg-2 arg-3 e-2 e-3 (cons e-2 '())))))))))))
(define Converter-groupBy (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (Converter-n--4439-5807-u--buildGroup e-2 e-3 arg-1 e-2 e-3 (cons e-2 '())))))))
(define Converter-n--4744-6099-u--compareKeys (lambda (arg-2 arg-3 arg-4 arg-5 arg-6) (let ((e-1 (car arg-2))) ((e-1 (arg-4 arg-5)) (arg-4 arg-6)))))
(define Converter-groupOn (lambda (arg-2 arg-3 arg-4) (Converter-groupBy (lambda (eta-0) (lambda (eta-1) (Converter-n--4744-6099-u--compareKeys arg-2 arg-4 arg-3 eta-0 eta-1))) arg-4)))
(define (Converter-addRowNumbers . any-args) (blodwen-error-quit "Encountered undefined name Converter.addRowNumbers"))
(define (Converter-copyDownFirstColumn . any-args) (blodwen-error-quit "Encountered undefined name Converter.copyDownFirstColumn"))
(define Converter-on (lambda (arg-3 arg-4 arg-5 arg-6) ((arg-3 (arg-4 arg-5)) (arg-4 arg-6))))
(define DataC-45String-strM (lambda (arg-0) (cond ((equal? arg-0 "") '())(else (cons (string-ref arg-0 0) (substring arg-0 1 (string-length arg-0)))))))
(define DataC-45String-with--asList-9518 (lambda (arg-0 arg-1) (cond ((equal? arg-0 "") (if (null? arg-1) (vector 0 ) (let ((e-0 (car arg-1))) (let ((e-1 (cdr arg-1))) (vector 1 e-0 e-1 (lambda () (DataC-45String-asList e-1)))))))(else (let ((e-0 (car arg-1))) (let ((e-1 (cdr arg-1))) (vector 1 e-0 e-1 (lambda () (DataC-45String-asList e-1)))))))))
(define DataC-45String-asList (lambda (arg-0) (DataC-45String-with--asList-9518 arg-0 (DataC-45String-strM arg-0))))
(define PreludeC-45Types-isSpace (lambda (arg-0) (cond ((equal? arg-0 #\ ) 1) ((equal? arg-0 (integer->char 9)) 1) ((equal? arg-0 (integer->char 13)) 1) ((equal? arg-0 (integer->char 10)) 1) ((equal? arg-0 (integer->char 12)) 1) ((equal? arg-0 (integer->char 11)) 1) ((equal? arg-0 (integer->char 160)) 1)(else 0))))
(define DataC-45String-with--ltrim-9542 (lambda (arg-0 arg-1) (cond ((equal? arg-0 "") (case (vector-ref arg-1 0) ((0) "")(else (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (let ((e-2 (vector-ref arg-1 3))) (let ((u--str (string-cons e-0 e-1))) (let ((sc2 (PreludeC-45Types-isSpace e-0))) (cond ((equal? sc2 1) (DataC-45String-with--ltrim-9542 e-1 (e-2))) (else u--str))))))))))(else (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (let ((e-2 (vector-ref arg-1 3))) (let ((u--str (string-cons e-0 e-1))) (let ((sc1 (PreludeC-45Types-isSpace e-0))) (cond ((equal? sc1 1) (DataC-45String-with--ltrim-9542 e-1 (e-2))) (else u--str)))))))))))
(define DataC-45String-ltrim (lambda (arg-0) (DataC-45String-with--ltrim-9542 arg-0 (DataC-45String-asList arg-0))))
(define DataC-45String-trim (lambda (ext-0) (DataC-45String-ltrim (string-reverse (DataC-45String-ltrim (string-reverse ext-0))))))
(define Converter-readDouble (lambda (arg-0) (cast-string-double (DataC-45String-trim arg-0))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Double (lambda (arg-0 arg-1) (let ((sc0 (or (and (>= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define Converter-descDoubleOrd (lambda (ext-0 ext-1) (Converter-on (lambda (eta-0) (lambda (eta-1) (PreludeC-45EqOrd-u--C-62C-61_Ord_Double eta-0 eta-1))) (lambda (eta-0) (Converter-readDouble eta-0)) ext-0 ext-1)))
(define Converter-C-33C-33 (lambda (arg-0 arg-1) (if (null? arg-0) "" (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cond ((equal? arg-1 0) e-2)(else (let ((e-4 (- arg-1 1))) (Converter-C-33C-33 e-3 e-4)))))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define Converter-groupOnColumn (lambda (arg-0 arg-1) (Converter-groupOn (cons (lambda (arg-676) (lambda (arg-679) (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-676 arg-679))) (lambda (arg-686) (lambda (arg-689) (PreludeC-45EqOrd-u--C-47C-61_Eq_String arg-686 arg-689)))) (lambda (u--row) (Converter-C-33C-33 u--row arg-0)) arg-1)))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define PreludeC-45TypesC-45List-filterAppend (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '()) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((sc1 (arg-2 e-1))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-filterAppend (cons arg-1 e-1) arg-2 e-2)) (else (PreludeC-45TypesC-45List-filterAppend arg-1 arg-2 e-2)))))))))
(define Converter-sortBy (lambda (arg-1 arg-2) (if (null? arg-2) '() (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((u--lesser (PreludeC-45TypesC-45List-filterAppend '() (lambda (u--x) ((arg-1 u--x) e-2)) e-3))) (let ((u--greater (PreludeC-45TypesC-45List-filterAppend '() (lambda (u--x) (let ((sc1 ((arg-1 u--x) e-2))) (cond ((equal? sc1 1) 0) (else 1)))) e-3))) (PreludeC-45TypesC-45List-tailRecAppend (Converter-sortBy arg-1 u--lesser) (PreludeC-45TypesC-45List-tailRecAppend (cons e-2 '()) (Converter-sortBy arg-1 u--greater))))))))))
(define Converter-sortTable (lambda (arg-0 arg-1 arg-2) (Converter-sortBy (lambda (eta-0) (lambda (eta-1) (Converter-on arg-0 (lambda (arg-3) (Converter-C-33C-33 arg-3 arg-1)) eta-0 eta-1))) arg-2)))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define Converter-ranks (lambda (arg-0 ext-0) (PreludeC-45Types-u--foldMap_Foldable_List (cons (lambda (arg-8474) (lambda (arg-8477) (PreludeC-45TypesC-45List-tailRecAppend arg-8474 arg-8477))) '()) (lambda (eta-0) eta-0) (PreludeC-45TypesC-45List-mapAppend '() (Converter-copyDownFirstColumn) (Converter-groupOnColumn arg-0 ((Converter-addRowNumbers) (Converter-sortTable (lambda (eta-0) (lambda (eta-1) (Converter-descDoubleOrd eta-0 eta-1))) arg-0 ext-0)))))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Num-u--mod_Integral_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-1 0))) (cond ((equal? sc0 0) (blodwen-euclidMod arg-0 arg-1))(else (blodwen-error-quit (string-append "ERROR: " "Unhandled input for Prelude.Num.case block in mod at Prelude.Num:94:3--96:44")))))))
(define PreludeC-45Show-n--3221-12652-u--showC-39 (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (if (null? e-3) (string-append arg-3 (let ((e-1 (car arg-1))) (e-1 e-2))) (PreludeC-45Show-n--3221-12652-u--showC-39 arg-1 arg-2 (string-append arg-3 (string-append (let ((e-1 (car arg-1))) (e-1 e-2)) ", ")) e-3)))))))
(define PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2) (string-append "[" (string-append (PreludeC-45Show-n--3221-12652-u--showC-39 arg-1 arg-2 "" arg-2) "]"))))
(define PreludeC-45Show-u--showPrec_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2 arg-3) (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 arg-1 arg-3)))
(define Main-main (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "Bienvenue au TP  Table.\xa;" ext-0))) (let ((act-2 (PreludeC-45IO-prim__putStr (string-append (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 csegen-1 u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_C-40ListC-32C-36aC-41 csegen-1 u--d u--x)))) (Converter-groupOn (cons (lambda (arg-676) (lambda (arg-679) (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-676 arg-679))) (lambda (arg-686) (lambda (arg-689) (PreludeC-45EqOrd-u--C-47C-61_Eq_Integer arg-686 arg-689)))) (lambda (arg-0) (PreludeC-45Num-u--mod_Integral_Integer arg-0 2)) (cons 1 (cons 3 (cons 2 (cons 0 (cons 5 (cons 4 (cons 6 (cons 8 (cons 7 '()))))))))))) "\xa;") ext-0))) (((let ((u--table5 (cons (cons "Alan Turing" (cons "19.5" '())) (cons (cons "Alonzo Church" (cons "20" '())) (cons (cons "Bertrand Russell" (cons "18" '())) (cons (cons "Dana Scott" (cons "19" '())) (cons (cons "Haskell Curry" (cons "20" '())) (cons (cons "Kurt Godel" (cons "17.5" '())) (cons (cons "Per Martin-Lof" (cons "18" '())) (cons (cons "Thierry Coquand" (cons "18" '())) (cons (cons "Wilhelm Ackermann" (cons "16" '())) '()))))))))))) (lambda () (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 csegen-38 u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_C-40ListC-32C-36aC-41 csegen-38 u--d u--x)))) (Converter-ranks 1 u--table5)) "\xa;") eta-0))))) ext-0)))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (let ((eff-0 (arg-1 u--w))) eff-0)))))
(collect-request-handler (lambda () (collect) (blodwen-run-finalisers)))
(PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0)))
  (collect 4)
  (blodwen-run-finalisers)
  
  )